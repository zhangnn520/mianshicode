#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time: 2025/1/14 0014 16:20
# @Author: Administrator
# @File: 11 - 二进制中1的个数.py
# @Project: mianshi
"""
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
关键点解析
1. n & (n - 1) 的作用
n & (n - 1) 是一个经典的位运算技巧，用于将 n 的二进制表示中的 最低位的 1 置为 0。

例如：

假设 n = 12，其二进制表示为 1100。

n - 1 = 11，二进制表示为 1011。

n & (n - 1) = 1100 & 1011 = 1000，即将最低位的 1 置为 0。

每次执行 n = n & (n - 1)，都会消除 n 的二进制表示中的一个 1。

2. 循环条件 while n
当 n 不为 0 时，说明 n 的二进制表示中还有 1，继续循环。

当 n 变为 0 时，说明所有 1 都被消除，循环结束。

3. 计数器 res
每次执行 n = n & (n - 1) 时，计数器 res 加 1，表示消除一个 1。

最终 res 的值就是 n 的二进制表示中 1 的个数。

示例运行
示例 1：
输入：n = 11
二进制表示：1011
执行过程：

n = 1011，n & (n - 1) = 1011 & 1010 = 1010，res = 1

n = 1010，n & (n - 1) = 1010 & 1001 = 1000，res = 2

n = 1000，n & (n - 1) = 1000 & 0111 = 0000，res = 3

n = 0，循环结束。

输出：3

示例 2：
输入：n = 0
二进制表示：0
执行过程：

n = 0，直接跳过循环。

输出：0

复杂度分析
时间复杂度：O(k)，其中 k 是 n 的二进制表示中 1 的个数。每次循环消除一个 1，直到 n 变为 0。

空间复杂度：O(1)，只使用了常数级别的额外空间。

总结
这个函数通过位运算 n & (n - 1) 高效地计算了整数 n 的二进制表示中 1 的个数。它的优点是：

高效：时间复杂度与 1 的个数成正比，而不是与二进制位数成正比。

简洁：代码非常简洁，易于理解和实现。

这种方法常用于需要统计二进制中 1 的个数的场景，例如在计算机科学中的位操作问题或算法竞赛中。
"""
class Solution:
    def HammingWeight(self,n:int)->int:
        res = 0
        while n:
            n=n&(n-1)
            res+=1
        return res

